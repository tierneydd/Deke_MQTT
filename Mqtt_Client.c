/**********************************************************************************************************************
 * \file Mqtt_Client.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Ifx_Types.h"
#include "string.h"
#include "Mqtt_Client.h"

/*********************************************************************************************************************/
/*-----------------------------------------------------Constants-----------------------------------------------------*/
/*********************************************************************************************************************/
static const char* TOPIC_LED1 = "IO/LED1";
static const char* TOPIC_LED2 = "IO/LED2";
static const char* TOPIC_BTN1 = "IO/BTN1";

static const char* MSG_ON = "ON";
static const char* MSG_OFF = "OFF";

static const struct mqtt_connect_client_info_t CLIENT_INFO =
{
    "TC375 LiteKit",
    NULL, NULL,                     /* No username or password (anonymous access)       */
    MQTT_CLIENT_KEEP_ALIVE,         /* Keep alive (PINGREQ) interval set to 60 seconds  */
    NULL, NULL,                     /* No LWT topic or message                          */
    0, 0                            /* Set QoS and retention LWT fields to 0            */
};

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
static mqtt_client_t* client;
static IfxPort_Pin current_pin;
static mqtt_connection_status_t connection_state = MQTT_CONNECT_DISCONNECTED;
static boolean can_publish = TRUE;

/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/
/* Callback called when an MQTT message is received */
static void data_receive_callback(void *arg, const u8_t *data, u16_t len, u8_t flags)
{
    LWIP_UNUSED_ARG(arg);

    const char* msg = (const char*)data;

    if (strncmp(msg, MSG_OFF, strlen(MSG_OFF)) == 0)
    {
        IfxPort_setPinHigh(current_pin.port, current_pin.pinIndex);
    }
    else if (strncmp(msg, MSG_ON, strlen(MSG_ON)) == 0)
    {
        IfxPort_setPinLow(current_pin.port, current_pin.pinIndex);
    }
}

/* Callback called when a response to an MQTT SUBSCRIBE request message is received */
static void subscribe_response_callback(void *arg, err_t err)
{
    LWIP_UNUSED_ARG(arg);

    if (err == ERR_OK)
    {
        /* SUBSCRIBE request was successful */
    }
    else
    {
        /* SUBSCRIBE request was unsuccessful */
    }
}

/* Callback for the state of a PUBLISH request */
static void publish_request_callback(void *arg, err_t err)
{
    LWIP_UNUSED_ARG(arg);

    if (err == ERR_OK)
    {
        /* PUBLISH acknowledged, OK to PUBLISH again */
        can_publish = TRUE;
    }
}

/* Callback called when a topic this client is subscribed to is published */
static void incoming_publish_callback(void *arg, const char *topic, u32_t tot_len)
{
    LWIP_UNUSED_ARG(arg);

    /* Check the published topic to determine which LED is being controlled
     * and save the corresponding port and pin for subsequent processing in
     * the data receive callback i.e. data_receive_callback(...) */
    if (strncmp(topic, TOPIC_LED1, strlen(TOPIC_LED1)) == 0)
    {
        current_pin = PORTPIN_LED1;
    }
    else if (strncmp(topic, TOPIC_LED2, strlen(TOPIC_LED2)) == 0)
    {
        current_pin = PORTPIN_LED2;
    }
}

/* Callback for the state changes of the TCP connection to the broker */
static void connection_state_callback(mqtt_client_t *client, void *arg, mqtt_connection_status_t status)
{
    const struct mqtt_connect_client_info_t* client_info = (const struct mqtt_connect_client_info_t*)arg;

    if (status == MQTT_CONNECT_ACCEPTED)
    {
        mqtt_sub_unsub(client, TOPIC_LED1, MQTT_CLIENT_SUB_QOS, subscribe_response_callback, LWIP_CONST_CAST(void*, client_info), 1);
        mqtt_sub_unsub(client, TOPIC_LED2, MQTT_CLIENT_SUB_QOS, subscribe_response_callback, LWIP_CONST_CAST(void*, client_info), 1);
    }

    connection_state = status;
}

/* Function to be called cyclically */
void mqtt_client_cyclic(void)
{
    static const uint32 DEBOUNCE_COUNTER_MAX = 0x5FFFF;
    static uint32 debounce_counter = 0;

    /* Primitive counter-based debouncing implemented for BTN1 to prevent a flood of PUBLISH
     * transmissions. If needed, DEBOUNCE_COUNTER_MAX can be changed to adjust the delay */
    if (debounce_counter < DEBOUNCE_COUNTER_MAX) {
        ++debounce_counter;
    }

    /* Proceed if BTN1 was debounced and any previous PUBLISH requests were acknowledged */
    if ((debounce_counter ==  DEBOUNCE_COUNTER_MAX) && can_publish && (IfxPort_getPinState(IfxPort_P00_7.port, IfxPort_P00_7.pinIndex) == 0))
    {
        /* Trigger an MQTT PUBLISH request for the "IO/BTN1" topic with an empty (NULL) message */
        mqtt_publish(client, TOPIC_BTN1, NULL, 0, MQTT_CLIENT_PUB_QOS, 0, publish_request_callback, LWIP_CONST_CAST(void*, &CLIENT_INFO));

        /* Ensure that the last PUBLISH is acknowledged before sending the next one */
        can_publish = FALSE;

        /* Reset BTN1 debounce counter */
        debounce_counter = 0;
    }
}

/* Returns the current MQTT connection status  */
mqtt_connection_status_t mqtt_client_connection_status(void)
{
    return connection_state;
}

/* MQTT client initialization and connection */
err_t mqtt_client_init(ip_addr_t* broker_ip)
{
    err_t err;

    /* Create a client instance */
    client = mqtt_client_new();

    /* Initiate client connection */
    err = mqtt_client_connect(client, broker_ip, MQTT_PORT, connection_state_callback, LWIP_CONST_CAST(void*, &CLIENT_INFO), &CLIENT_INFO);

    /* Setup callbacks - this has to be done after the connection request since mqtt_client_connection(...)
     * zeroes out the mqtt_client_t structure passed into it */
    mqtt_set_inpub_callback(client, incoming_publish_callback, data_receive_callback, LWIP_CONST_CAST(void*, &CLIENT_INFO));

    /* Set input mode for the BUTTON pin */
    IfxPort_setPinMode(PORTPIN_BTN1.port, PORTPIN_BTN1.pinIndex, IfxPort_Mode_inputPullUp);

    /* Set output modes for LED pins */
    IfxPort_setPinModeOutput(PORTPIN_LED1.port, PORTPIN_LED1.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(PORTPIN_LED2.port, PORTPIN_LED2.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    /* Turn off both LEDs */
    IfxPort_setPinHigh(PORTPIN_LED1.port, PORTPIN_LED1.pinIndex);
    IfxPort_setPinHigh(PORTPIN_LED2.port, PORTPIN_LED2.pinIndex);

    /* Initialize current pin to P00.5 */
    current_pin = IfxPort_P00_5;

    return err;
}
